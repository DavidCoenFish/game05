TextBlock/ TextGeometry could have no concept of render target? allow draw to screen or ui block?
would this allow ui_block to be more generic, holds the render target and some compisition info, that is the pixel size

ui_hierarchy
i_ui_hierarchy_node
    ui_hierarchy_node_text
        ui_block
    ui_hierarchy_node_fill
    ui_hierarchy_node_drop_shadow
    ?ui_hierarchy_node_margin
    ?auto scroll
    ?interactive scroll
    ?stack
    ?grid


UiBlock rename as UiRenderTarget, is a render target, with size
UiDraw is a pair of geometry and texture to get drawn
what about canvas? 
UiCanvas rename as UiHierarchyNode
    data of how to translate parent size into our size
        ratio and pixel offset for top, left, bottom, right?
        or speify a pivot on parent and self, and sepcify size (as float ratio and int pisel offset)
        flag, use calculated size as max, and collapse to child required

    UiRenderTarget
    array of UiDraw/ array of UiHierarchyNode


given dag nod for screen size, (the parent size)
UIManager::Draw(DrawFrame, IRenderTarget (with size), UiHierarchyNode)

draw to back buffer vrs draw to render target? root hierarchy node? or node that takes an external render target

UIManager::Draw(draw frame, render target, geometry, texture)
UIManager::DrawHierarchy(draw frame, UiHierarchyNode)

UiHierarchyNode
    array children UiHierarchyNode
    UiTexture, render target for children or custom texture
    UiGeometry, geometry or null, top level may not need geometry
    rules to make geometry/ render target size based on parent size
    calculated size~ or authorative size is in UiTexture
    
    content may change, needing re-draw, size may change needing re draw...


how does text fit in? is UiGeometry part of the array children UiHierarchyNode


UiHierarchyNode
    array children <UiHierarchyNode, UiGeometry>
    UiTexture, render target for children to draw to, or texture
    rules to update size based on parent size, also uv
    // given max size, return needed size?

for text, it outputs to a UiTexture, and gets input from UiHierarchyNode size


i_ui_content
    UiContentImage
    UiContentText
    UiContentCanvas
    UiContentDock //grid/ or a canvas that doesn't allow overlap, 
    UiContentStack // so, what controls how children have positions generated
    // build scroll auto/manual into geometry ui calculation?
    //UiContentScrollAuto
    //UiContentScrollManual

    UiContentEffectDropShadow
    UiContentEffectStroke
    UiContentEffectHighlight // mouse over/ mouse down
    UiContentEffectShine

    UiContentMixMask //combine rgb from child 0 and use child 1 as a mask as alpha
    UiContentEffectRoundCorners // draws round corners in black

each content has an on click? on select sound? block mouse over/ navigation

ui scale effects font size and pixel portion of coords
ui coord have a ratio and a pixel size

canvas child position specified by 


i_ui_content
    void UpdateChildGeometry(out render target size4, out geometry pos4, out geometry uv4, in child)
    int2 CalculateNeededSize(max size2)

+ new game
> continue
i info
(gear) options
x exit

todo:
X application coord test, add two panels bottom right
- have a stack of text, the fps, build details, build time and version
- have a stack of buttons, mask out rounded corners and icon, drop shadow
- copy texture resource
- transition effect, when reflecting model, how to trigger transition of node being closed, 

longterm:
- split shader in shader_common and shader_instance, with shader instance having the memory handles of the constant buffer
- change GetShaderResourceHeapWrapperItem to true raw pointer, use raw ptr more often


i_ui_data
i_ui_data_server
    i_ui_data GetData(key)
// formatting hints by class name? or no layout in model
//ui_data_string_small_right_no_wrap_auto_scroll
ui_data_string
ui_data_container // array of ui_data
ui_data_icon_button // icon id (string), lable, enable flag, on click, on navigate?
ui_data_expander // string, 

translation_collection
    string GetDefaultLocale()
    vector<string> GetLocaleList(locale) // return array of keys? or array of pair<key,value>
    std::string GetValue(locale, key)
    void AppendData(locale, array<key, value>);
    void ClearData()

so the problem, is when does layout size/ geometry get updated.
UIManager::UpdateLayout // Make UIHierarchyNode if needed, get things ready for draw
    UIHierarchyNode::UpdateLayout
        // Create, delete, change content type
        // Update content
        // Update Texture

when is the geometry updated, geometry is part of the children data next to the node

SMIL
https://en.wikipedia.org/wiki/SVG_animation

https://github.com/sammycage/lunasvg
https://github.com/memononen/nanosvg

calculating desired size, what defines the layout?
content text -> get text bounds + margin
    does text get the chooice to flag wrap on parent width, or constant width? us a uv coord?
content stack -> children + gap between children + margin


UIHierarchyNode // N0 
    _texture // T0 parent's texture what we draw the children to
    _child_data_array A0
        _node // N1 child node
        _geometry // G1 geometry to draw the child nodes texture onto the parents texture
    _content C0 // controls hierarchy, layout, texture size T0/ geometry size G0
    //_layout_data

Manager Draw
    Node(N0)::Draw
        for each A0
            call Node(N1)::Draw 
        Set T0 as render target
        for each A0
            render T1 with Geometry G1

Manager Update(in_size)
    Node(N0)::UpdateHierarchy
        _content(C0) rebuild to match model
        _content(C0)::BuildChildArray(A0)

    // texture/ desired size may be bigger than max size allowed by input/ parent. deal with that by reducing range of uv on geometry to match
    // but how to deal with that at the tope level, it doesn't have geometry (there is no G0), so do we start at N0 and work on A0
    Node(N0)::UpdateSize(input size(S0))// like the render target size, use root node texture size? or is top level size input to the update
        for each A0:
            Node(N1)::CalculateSize(input size(S0)) // Content determins how recusion happens?
                Content(C1)::CalculateSize(A1) // for stack, using it's layout data?
                    what is max size after margin(S1a)
                    for each A1:
                        Node(N2) given S1a, what is the desired size -> S1_2, S1 for child
                        //Node(N2)::CalculateSize(S1_2)? or 
                        //Node(N2)::SetSize(S1_2)
                        // stack may have an optional max size for child? or just let child grow... flags
                        // flag for shrinking size to min, auto or manual scroll
                // presume using _content(C1, A1) and does magic to shrink/ strech self to accomidate dealing with size(S0)
                sets texture size(T1) with size from Content(C1)
                sets geometry size(G1) with pos_uv from Content(C1)

    // Sanity check 0: if to level node (N0) has content text (C0) that can't auto scroll or manual scroll if size is bigger than size(S0)
    // Rule: top level component can not require scrolling? or default content for top level?

    // Sanity check 1: if stack is top level, margin for auto scroll, again, there is no G0
    // have a default content? and/or a UIContentRoot? UIDataRoot?

    // Sanity check 2: so the root nod has a default/ root type. but now i want a child stack with margin and text.
N(0) root
    N(1) stack
        N(2) text

other than the locale needed for the TextManager, the ui is unaware of local, locale is internal to the model, model justs hands strings, or runs of strings
to the ui manager.

root node has a given target size, [px, py]
root node has a content, if content thinks it larger than parent size, it might auto scroll or have manual scroll widgets in margin
 so content contols texture size, to work out size it may need to know data about children
 content controls geometry size, fitting the desired size into what is avliable
 are these sizes expressed by layout? what about text. 
 does layout express margin

 node->GetDesiredSize(parent_size)
 move calculation to layout? input size, calculate output size and offset, uv?

 _container->CalculateSize(
    out_texture_target_size, // VectorInt2
    out_geometry_pos, // VectorFloat4
    out_geometry_uv, // VectorFloat4
    )






